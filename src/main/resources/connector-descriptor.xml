<?xml version="1.0" encoding="UTF-8"?>
<GenericConnectorDescriptor>
<!--<GenericConnectorDescriptor xmlns="http://www.boomi.com/connector/descriptor"-->
<!--                            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"-->
<!--                            xsi:schemaLocation="http://www.boomi.com/connector/descriptor genericconnectordesc.xsd">-->
    <field id="controllerUri" label="URI" type="string">
        <helpText>The URI to the Pravega controller in the form tcp://host:port</helpText>
    </field>
    <field id="scope" label="Scope" type="string">
        <helpText>The Pravega scope containing the data stream.</helpText>
    </field>
    <field id="stream" label="Stream Name" type="string">
        <helpText>The name of the data stream.</helpText>
    </field>
    <field id="createScope" label="Create Scope" type="boolean">
        <helpText>When checked, Pravega scope will be automatically created. Only enable this if Pravega is running in
            stand-alone mode.
        </helpText>
        <defaultValue>true</defaultValue>
    </field>
    <field id="enableAuth" label="Pravega Authentication Required" type="boolean">
        <helpText>Indicates whether authentication is required for Pravega.</helpText>
        <defaultValue>false</defaultValue>
    </field>
    <field id="userName" label="Pravega User Name" type="string">
        <helpText>The Pravega user.</helpText>
    </field>
    <field id="password" label="Pravega Password" type="password">
        <helpText>The Pravega user's password.</helpText>
    </field>
    <testConnection method="CUSTOM"/>
    <operation types="QUERY" supportsBrowse="false" customTypeLabel="Read">
        <field id="readerGroup" label="Pravega Reader Group" type="string">
            <helpText>The name of the reader group for this reader within Pravega. Each reader group will maintain
                its position in the stream between executions. Note: a reader group will distribute events between its
                readers. Be careful when naming your reader group so that you do not mistakenly share events with
                another reader. If different readers each need to process all events in the stream, they should
                use different reader groups.
            </helpText>
        </field>
        <field id="readTimeout" label="Read Timeout (ms)" type="integer">
            <helpText>The maximum amount of time the reader will wait for the next event from Pravega (in
                milliseconds).
            </helpText>
            <defaultValue>2000</defaultValue>
        </field>
        <field id="maxEventsPerExecution" label="Max Events per Execution" type="integer">
            <helpText>For each execution of the operation, The maximum number of events the reader will read before
                moving to the next component in the process. For example, if this is set to 100000 events, the operation
                will read a maximum of 100000 events. If it hits the tail of the stream (no more events), or this limit
                (100000 events), it will exit execution and the collection of events will be sent to the next component
                in the process flow. If this is set to 0, the operation will continue reading from the stream until it
                hits the tail (there are no more events). Note that if there are a lot of events, this may overload the
                Boomi document cache.
            </helpText>
            <defaultValue>100000</defaultValue>
        </field>
        <field id="maxReadTimePerExecution" label="Max Read Time per Execution (seconds)" type="integer">
            <helpText>For each execution of the operation, The maximum number of seconds the reader will read and
                collect events from the stream before moving to the next component in the process. For example, if this
                is set to 30 seconds, the operation will spend a maximum of 30 seconds reading events from the stream.
                If it hits the tail of the stream (no more events), or this time (30 seconds), it will exit execution
                and the collection of events will be sent to the next component in the process flow. If this is set to
                0, the operation will continue reading from the stream until it hits the tail (there are no more
                events). Note that if there are a lot of events, this may overload the Boomi document cache.
            </helpText>
            <defaultValue>30</defaultValue>
        </field>
    </operation>
    <operation types="CREATE" supportsBrowse="false" customTypeLabel="Write">
        <field id="routingKeyType" label="Routing Key Type" type="string">
            <helpText>The type of routing key to use for each event.
                "Fixed" means to use the literal value of the Routing Key below.
                "JsonReference" means the event data is JSON and the value will be extracted from the body using the
                Routing Key below as a JSON reference (i.e. a value of "myVar" will look for the "myVar" key in the JSON
                of each event, and use its corresponding value as the routing key for that event).
            </helpText>
            <allowedValue>
                <value>Fixed</value>
            </allowedValue>
            <allowedValue>
                <value>JsonReference</value>
            </allowedValue>
        </field>
        <field id="routingKey" label="Routing Key" type="string">
            <helpText>The routing key to use for each event written to the stream. If the Routing Key Type is "Fixed",
                this value will be used literally and will be the same for every event. If the Routing Key Type is
                "JsonReference", the routing key for each event will be evaluated from the JSON body, using the
                reference provided here.
            </helpText>
        </field>
    </operation>
</GenericConnectorDescriptor>
